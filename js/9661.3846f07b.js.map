{"version":3,"file":"js/9661.3846f07b.js","mappings":"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","sources":["webpack://bradley-consuegra-portfolio/./node_modules/@tsparticles/updater-out-modes/browser/Utils.js","webpack://bradley-consuegra-portfolio/./node_modules/@tsparticles/updater-out-modes/browser/BounceOutMode.js","webpack://bradley-consuegra-portfolio/./node_modules/@tsparticles/updater-out-modes/browser/DestroyOutMode.js","webpack://bradley-consuegra-portfolio/./node_modules/@tsparticles/updater-out-modes/browser/NoneOutMode.js","webpack://bradley-consuegra-portfolio/./node_modules/@tsparticles/updater-out-modes/browser/OutOutMode.js","webpack://bradley-consuegra-portfolio/./node_modules/@tsparticles/updater-out-modes/browser/OutOfCanvasUpdater.js"],"sourcesContent":["import { getRangeValue } from \"@tsparticles/engine\";\r\nconst minVelocity = 0, boundsMin = 0;\r\nexport function bounceHorizontal(data) {\r\n    if ((data.outMode !== \"bounce\" && data.outMode !== \"split\") ||\r\n        (data.direction !== \"left\" && data.direction !== \"right\")) {\r\n        return;\r\n    }\r\n    if (data.bounds.right < boundsMin && data.direction === \"left\") {\r\n        data.particle.position.x = data.size + data.offset.x;\r\n    }\r\n    else if (data.bounds.left > data.canvasSize.width && data.direction === \"right\") {\r\n        data.particle.position.x = data.canvasSize.width - data.size - data.offset.x;\r\n    }\r\n    const velocity = data.particle.velocity.x;\r\n    let bounced = false;\r\n    if ((data.direction === \"right\" &&\r\n        data.bounds.right >= data.canvasSize.width &&\r\n        velocity > minVelocity) ||\r\n        (data.direction === \"left\" && data.bounds.left <= boundsMin && velocity < minVelocity)) {\r\n        const newVelocity = getRangeValue(data.particle.options.bounce.horizontal.value);\r\n        data.particle.velocity.x *= -newVelocity;\r\n        bounced = true;\r\n    }\r\n    if (!bounced) {\r\n        return;\r\n    }\r\n    const minPos = data.offset.x + data.size;\r\n    if (data.bounds.right >= data.canvasSize.width && data.direction === \"right\") {\r\n        data.particle.position.x = data.canvasSize.width - minPos;\r\n    }\r\n    else if (data.bounds.left <= boundsMin && data.direction === \"left\") {\r\n        data.particle.position.x = minPos;\r\n    }\r\n    if (data.outMode === \"split\") {\r\n        data.particle.destroy();\r\n    }\r\n}\r\nexport function bounceVertical(data) {\r\n    if ((data.outMode !== \"bounce\" && data.outMode !== \"split\") ||\r\n        (data.direction !== \"bottom\" && data.direction !== \"top\")) {\r\n        return;\r\n    }\r\n    if (data.bounds.bottom < boundsMin && data.direction === \"top\") {\r\n        data.particle.position.y = data.size + data.offset.y;\r\n    }\r\n    else if (data.bounds.top > data.canvasSize.height && data.direction === \"bottom\") {\r\n        data.particle.position.y = data.canvasSize.height - data.size - data.offset.y;\r\n    }\r\n    const velocity = data.particle.velocity.y;\r\n    let bounced = false;\r\n    if ((data.direction === \"bottom\" &&\r\n        data.bounds.bottom >= data.canvasSize.height &&\r\n        velocity > minVelocity) ||\r\n        (data.direction === \"top\" && data.bounds.top <= boundsMin && velocity < minVelocity)) {\r\n        const newVelocity = getRangeValue(data.particle.options.bounce.vertical.value);\r\n        data.particle.velocity.y *= -newVelocity;\r\n        bounced = true;\r\n    }\r\n    if (!bounced) {\r\n        return;\r\n    }\r\n    const minPos = data.offset.y + data.size;\r\n    if (data.bounds.bottom >= data.canvasSize.height && data.direction === \"bottom\") {\r\n        data.particle.position.y = data.canvasSize.height - minPos;\r\n    }\r\n    else if (data.bounds.top <= boundsMin && data.direction === \"top\") {\r\n        data.particle.position.y = minPos;\r\n    }\r\n    if (data.outMode === \"split\") {\r\n        data.particle.destroy();\r\n    }\r\n}\r\n","import { calculateBounds, } from \"@tsparticles/engine\";\r\nimport { bounceHorizontal, bounceVertical } from \"./Utils.js\";\r\nexport class BounceOutMode {\r\n    constructor(container) {\r\n        this.container = container;\r\n        this.modes = [\r\n            \"bounce\",\r\n            \"split\",\r\n        ];\r\n    }\r\n    update(particle, direction, delta, outMode) {\r\n        if (!this.modes.includes(outMode)) {\r\n            return;\r\n        }\r\n        const container = this.container;\r\n        let handled = false;\r\n        for (const [, plugin] of container.plugins) {\r\n            if (plugin.particleBounce !== undefined) {\r\n                handled = plugin.particleBounce(particle, delta, direction);\r\n            }\r\n            if (handled) {\r\n                break;\r\n            }\r\n        }\r\n        if (handled) {\r\n            return;\r\n        }\r\n        const pos = particle.getPosition(), offset = particle.offset, size = particle.getRadius(), bounds = calculateBounds(pos, size), canvasSize = container.canvas.size;\r\n        bounceHorizontal({ particle, outMode, direction, bounds, canvasSize, offset, size });\r\n        bounceVertical({ particle, outMode, direction, bounds, canvasSize, offset, size });\r\n    }\r\n}\r\n","import { Vector, getDistances, isPointInside, } from \"@tsparticles/engine\";\r\nconst minVelocity = 0;\r\nexport class DestroyOutMode {\r\n    constructor(container) {\r\n        this.container = container;\r\n        this.modes = [\"destroy\"];\r\n    }\r\n    update(particle, direction, _delta, outMode) {\r\n        if (!this.modes.includes(outMode)) {\r\n            return;\r\n        }\r\n        const container = this.container;\r\n        switch (particle.outType) {\r\n            case \"normal\":\r\n            case \"outside\":\r\n                if (isPointInside(particle.position, container.canvas.size, Vector.origin, particle.getRadius(), direction)) {\r\n                    return;\r\n                }\r\n                break;\r\n            case \"inside\": {\r\n                const { dx, dy } = getDistances(particle.position, particle.moveCenter), { x: vx, y: vy } = particle.velocity;\r\n                if ((vx < minVelocity && dx > particle.moveCenter.radius) ||\r\n                    (vy < minVelocity && dy > particle.moveCenter.radius) ||\r\n                    (vx >= minVelocity && dx < -particle.moveCenter.radius) ||\r\n                    (vy >= minVelocity && dy < -particle.moveCenter.radius)) {\r\n                    return;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        container.particles.remove(particle, undefined, true);\r\n    }\r\n}\r\n","import { Vector, isPointInside, } from \"@tsparticles/engine\";\r\nconst minVelocity = 0;\r\nexport class NoneOutMode {\r\n    constructor(container) {\r\n        this.container = container;\r\n        this.modes = [\"none\"];\r\n    }\r\n    update(particle, direction, delta, outMode) {\r\n        if (!this.modes.includes(outMode)) {\r\n            return;\r\n        }\r\n        if ((particle.options.move.distance.horizontal &&\r\n            (direction === \"left\" || direction === \"right\")) ??\r\n            (particle.options.move.distance.vertical &&\r\n                (direction === \"top\" || direction === \"bottom\"))) {\r\n            return;\r\n        }\r\n        const gravityOptions = particle.options.move.gravity, container = this.container, canvasSize = container.canvas.size, pRadius = particle.getRadius();\r\n        if (!gravityOptions.enable) {\r\n            if ((particle.velocity.y > minVelocity && particle.position.y <= canvasSize.height + pRadius) ||\r\n                (particle.velocity.y < minVelocity && particle.position.y >= -pRadius) ||\r\n                (particle.velocity.x > minVelocity && particle.position.x <= canvasSize.width + pRadius) ||\r\n                (particle.velocity.x < minVelocity && particle.position.x >= -pRadius)) {\r\n                return;\r\n            }\r\n            if (!isPointInside(particle.position, container.canvas.size, Vector.origin, pRadius, direction)) {\r\n                container.particles.remove(particle);\r\n            }\r\n        }\r\n        else {\r\n            const position = particle.position;\r\n            if ((!gravityOptions.inverse &&\r\n                position.y > canvasSize.height + pRadius &&\r\n                direction === \"bottom\") ||\r\n                (gravityOptions.inverse && position.y < -pRadius && direction === \"top\")) {\r\n                container.particles.remove(particle);\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { Vector, calculateBounds, getDistances, getRandom, isPointInside, randomInRange, } from \"@tsparticles/engine\";\r\nconst minVelocity = 0, minDistance = 0;\r\nexport class OutOutMode {\r\n    constructor(container) {\r\n        this.container = container;\r\n        this.modes = [\"out\"];\r\n    }\r\n    update(particle, direction, delta, outMode) {\r\n        if (!this.modes.includes(outMode)) {\r\n            return;\r\n        }\r\n        const container = this.container;\r\n        switch (particle.outType) {\r\n            case \"inside\": {\r\n                const { x: vx, y: vy } = particle.velocity;\r\n                const circVec = Vector.origin;\r\n                circVec.length = particle.moveCenter.radius;\r\n                circVec.angle = particle.velocity.angle + Math.PI;\r\n                circVec.addTo(Vector.create(particle.moveCenter));\r\n                const { dx, dy } = getDistances(particle.position, circVec);\r\n                if ((vx <= minVelocity && dx >= minDistance) ||\r\n                    (vy <= minVelocity && dy >= minDistance) ||\r\n                    (vx >= minVelocity && dx <= minDistance) ||\r\n                    (vy >= minVelocity && dy <= minDistance)) {\r\n                    return;\r\n                }\r\n                particle.position.x = Math.floor(randomInRange({\r\n                    min: 0,\r\n                    max: container.canvas.size.width,\r\n                }));\r\n                particle.position.y = Math.floor(randomInRange({\r\n                    min: 0,\r\n                    max: container.canvas.size.height,\r\n                }));\r\n                const { dx: newDx, dy: newDy } = getDistances(particle.position, particle.moveCenter);\r\n                particle.direction = Math.atan2(-newDy, -newDx);\r\n                particle.velocity.angle = particle.direction;\r\n                break;\r\n            }\r\n            default: {\r\n                if (isPointInside(particle.position, container.canvas.size, Vector.origin, particle.getRadius(), direction)) {\r\n                    return;\r\n                }\r\n                switch (particle.outType) {\r\n                    case \"outside\": {\r\n                        particle.position.x =\r\n                            Math.floor(randomInRange({\r\n                                min: -particle.moveCenter.radius,\r\n                                max: particle.moveCenter.radius,\r\n                            })) + particle.moveCenter.x;\r\n                        particle.position.y =\r\n                            Math.floor(randomInRange({\r\n                                min: -particle.moveCenter.radius,\r\n                                max: particle.moveCenter.radius,\r\n                            })) + particle.moveCenter.y;\r\n                        const { dx, dy } = getDistances(particle.position, particle.moveCenter);\r\n                        if (particle.moveCenter.radius) {\r\n                            particle.direction = Math.atan2(dy, dx);\r\n                            particle.velocity.angle = particle.direction;\r\n                        }\r\n                        break;\r\n                    }\r\n                    case \"normal\": {\r\n                        const warp = particle.options.move.warp, canvasSize = container.canvas.size, newPos = {\r\n                            bottom: canvasSize.height + particle.getRadius() + particle.offset.y,\r\n                            left: -particle.getRadius() - particle.offset.x,\r\n                            right: canvasSize.width + particle.getRadius() + particle.offset.x,\r\n                            top: -particle.getRadius() - particle.offset.y,\r\n                        }, sizeValue = particle.getRadius(), nextBounds = calculateBounds(particle.position, sizeValue);\r\n                        if (direction === \"right\" &&\r\n                            nextBounds.left > canvasSize.width + particle.offset.x) {\r\n                            particle.position.x = newPos.left;\r\n                            particle.initialPosition.x = particle.position.x;\r\n                            if (!warp) {\r\n                                particle.position.y = getRandom() * canvasSize.height;\r\n                                particle.initialPosition.y = particle.position.y;\r\n                            }\r\n                        }\r\n                        else if (direction === \"left\" && nextBounds.right < -particle.offset.x) {\r\n                            particle.position.x = newPos.right;\r\n                            particle.initialPosition.x = particle.position.x;\r\n                            if (!warp) {\r\n                                particle.position.y = getRandom() * canvasSize.height;\r\n                                particle.initialPosition.y = particle.position.y;\r\n                            }\r\n                        }\r\n                        if (direction === \"bottom\" &&\r\n                            nextBounds.top > canvasSize.height + particle.offset.y) {\r\n                            if (!warp) {\r\n                                particle.position.x = getRandom() * canvasSize.width;\r\n                                particle.initialPosition.x = particle.position.x;\r\n                            }\r\n                            particle.position.y = newPos.top;\r\n                            particle.initialPosition.y = particle.position.y;\r\n                        }\r\n                        else if (direction === \"top\" && nextBounds.bottom < -particle.offset.y) {\r\n                            if (!warp) {\r\n                                particle.position.x = getRandom() * canvasSize.width;\r\n                                particle.initialPosition.x = particle.position.x;\r\n                            }\r\n                            particle.position.y = newPos.bottom;\r\n                            particle.initialPosition.y = particle.position.y;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { BounceOutMode } from \"./BounceOutMode.js\";\r\nimport { DestroyOutMode } from \"./DestroyOutMode.js\";\r\nimport { NoneOutMode } from \"./NoneOutMode.js\";\r\nimport { OutOutMode } from \"./OutOutMode.js\";\r\nconst checkOutMode = (outModes, outMode) => {\r\n    return (outModes.default === outMode ||\r\n        outModes.bottom === outMode ||\r\n        outModes.left === outMode ||\r\n        outModes.right === outMode ||\r\n        outModes.top === outMode);\r\n};\r\nexport class OutOfCanvasUpdater {\r\n    constructor(container) {\r\n        this._updateOutMode = (particle, delta, outMode, direction) => {\r\n            for (const updater of this.updaters) {\r\n                updater.update(particle, direction, delta, outMode);\r\n            }\r\n        };\r\n        this.container = container;\r\n        this.updaters = [];\r\n    }\r\n    init(particle) {\r\n        this.updaters = [];\r\n        const outModes = particle.options.move.outModes;\r\n        if (checkOutMode(outModes, \"bounce\")) {\r\n            this.updaters.push(new BounceOutMode(this.container));\r\n        }\r\n        else if (checkOutMode(outModes, \"out\")) {\r\n            this.updaters.push(new OutOutMode(this.container));\r\n        }\r\n        else if (checkOutMode(outModes, \"destroy\")) {\r\n            this.updaters.push(new DestroyOutMode(this.container));\r\n        }\r\n        else if (checkOutMode(outModes, \"none\")) {\r\n            this.updaters.push(new NoneOutMode(this.container));\r\n        }\r\n    }\r\n    isEnabled(particle) {\r\n        return !particle.destroyed && !particle.spawning;\r\n    }\r\n    update(particle, delta) {\r\n        const outModes = particle.options.move.outModes;\r\n        this._updateOutMode(particle, delta, outModes.bottom ?? outModes.default, \"bottom\");\r\n        this._updateOutMode(particle, delta, outModes.left ?? outModes.default, \"left\");\r\n        this._updateOutMode(particle, delta, outModes.right ?? outModes.default, \"right\");\r\n        this._updateOutMode(particle, delta, outModes.top ?? outModes.default, \"top\");\r\n    }\r\n}\r\n"],"names":["minVelocity","boundsMin","bounceHorizontal","data","outMode","direction","bounds","right","particle","position","x","size","offset","left","canvasSize","width","velocity","bounced","newVelocity","getRangeValue","options","bounce","horizontal","value","minPos","destroy","bounceVertical","bottom","y","top","height","vertical","BounceOutMode","constructor","container","this","modes","update","delta","includes","handled","plugin","plugins","undefined","particleBounce","pos","getPosition","getRadius","calculateBounds","canvas","DestroyOutMode","_delta","outType","isPointInside","Vector","origin","dx","dy","getDistances","moveCenter","vx","vy","radius","particles","remove","NoneOutMode","move","distance","gravityOptions","gravity","pRadius","enable","inverse","minDistance","OutOutMode","circVec","length","angle","Math","PI","addTo","create","floor","randomInRange","min","max","newDx","newDy","atan2","warp","newPos","sizeValue","nextBounds","initialPosition","getRandom","checkOutMode","outModes","default","OutOfCanvasUpdater","_updateOutMode","updater","updaters","init","push","isEnabled","destroyed","spawning"],"sourceRoot":""}